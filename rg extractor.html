<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ultimate Game Asset Ripper</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    :root {
      --primary: #4f46e5; --bg: #0f172a; --card: #1e293b; --text: #f8fafc;
      --accent-img: #38bdf8; --accent-aud: #f472b6; --accent-dat: #94a3b8;
    }
    body {
      font-family: 'Segoe UI', Roboto, sans-serif;
      background: var(--bg); color: var(--text);
      margin: 0; padding: 0; height: 100vh;
      display: flex; flex-direction: column; overflow: hidden;
    }

    /* Top Bar */
    header {
      background: #111; padding: 1rem 1.5rem;
      display: flex; align-items: center; justify-content: space-between;
      border-bottom: 1px solid #333;
    }
    .brand h1 { margin: 0; font-size: 1.2rem; font-weight: 800; letter-spacing: 0.5px; }
    .brand span { color: var(--primary); }
    .brand p { margin: 0; font-size: 0.75rem; color: #64748b; }

    /* Controls Area */
    .toolbar {
      padding: 1rem; background: #162032; border-bottom: 1px solid #333;
      display: flex; gap: 1rem; flex-wrap: wrap; align-items: center;
    }

    .file-upload {
      position: relative; overflow: hidden;
      background: var(--primary); color: white;
      padding: 0.6rem 1.2rem; border-radius: 6px;
      font-weight: 600; cursor: pointer; transition: 0.2s;
      display: flex; align-items: center; gap: 8px;
    }
    .file-upload:hover { background: #4338ca; }
    .file-upload input { position: absolute; left: 0; top: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; }

    .filters { display: flex; gap: 0.5rem; background: #0f172a; padding: 4px; border-radius: 6px; border: 1px solid #333; }
    .filter-btn {
      background: transparent; border: none; color: #94a3b8;
      padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.85rem; font-weight: 600;
    }
    .filter-btn.active { background: #334155; color: white; }
    
    .actions { margin-left: auto; display: flex; gap: 10px; }
    .action-btn {
      background: #334155; color: white; border: none; padding: 0.6rem 1rem;
      border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 0.85rem;
    }
    .action-btn:hover { background: #475569; }
    .action-btn.download-all { background: #059669; }
    .action-btn.download-all:hover { background: #047857; }

    /* Progress Bar */
    .progress-container { width: 100%; height: 4px; background: #333; display: none; }
    .progress-bar { height: 100%; background: var(--primary); width: 0%; transition: width 0.2s; }

    /* Grid */
    #grid {
      flex: 1; padding: 1.5rem; overflow-y: auto;
      display: grid; grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      grid-auto-rows: min-content; gap: 1.5rem;
    }

    .card {
      background: var(--card); border: 1px solid #334155; border-radius: 8px;
      padding: 10px; display: flex; flex-direction: column; position: relative;
    }
    .card-preview {
      height: 120px; background: #0f172a; border-radius: 6px;
      margin-bottom: 10px; display: flex; align-items: center; justify-content: center;
      overflow: hidden; position: relative;
    }
    .card-preview img { width: 100%; height: 100%; object-fit: contain; }
    .card-preview audio { width: 90%; height: 30px; }
    
    .type-icon { font-size: 0.8rem; font-weight: 900; padding: 4px 8px; border: 2px solid #334155; border-radius: 4px; color: #64748b; }

    .card-meta { font-size: 0.75rem; color: #94a3b8; margin-bottom: 4px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .card-tags { display: flex; gap: 6px; margin-bottom: 8px; }
    .tag { font-size: 0.65rem; font-weight: 700; padding: 2px 6px; border-radius: 4px; text-transform: uppercase; }
    
    .tag-img { background: #0c4a6e; color: var(--accent-img); }
    .tag-aud { background: #831843; color: var(--accent-aud); }
    .tag-dat { background: #334155; color: var(--accent-dat); }

    .card-btn {
      margin-top: auto; padding: 6px; text-align: center;
      background: #334155; color: white; text-decoration: none;
      border-radius: 4px; font-size: 0.8rem; font-weight: 600;
    }
    .card-btn:hover { background: var(--primary); }

    .empty-state { grid-column: 1 / -1; text-align: center; color: #475569; margin-top: 4rem; }
  </style>
</head>
<body>

<header>
  <div class="brand">
    <h1>Game<span>Ripper</span></h1>
    <p>Extract Images, Audio & Unity Files from archives</p>
  </div>
  <div id="status">Waiting for file...</div>
</header>

<div class="progress-container" id="progressContainer"><div class="progress-bar" id="progressBar"></div></div>

<div class="toolbar">
  <div class="file-upload">
    <span>ðŸ“‚ Open File / Zip / APK</span>
    <input type="file" id="fileInput" />
  </div>

  <div class="filters">
    <button class="filter-btn active" onclick="filter('all')">All</button>
    <button class="filter-btn" onclick="filter('image')">Images</button>
    <button class="filter-btn" onclick="filter('audio')">Audio</button>
    <button class="filter-btn" onclick="filter('data')">Data</button>
  </div>

  <div class="actions">
    <button class="action-btn" onclick="clearAll()">Clear</button>
    <button class="action-btn download-all" id="dlAllBtn" onclick="downloadAll()" disabled>Download All (0)</button>
  </div>
</div>

<div id="grid">
  <div class="empty-state">
    Drag & Drop a file here (EXE, DLL, ZIP, APK, OBB, DATA)<br>
    We will find hidden Assets inside.
  </div>
</div>

<!-- WORKER: The Brain -->
<script id="worker-code" type="javascript/worker">
  self.onmessage = function(e) {
    const { buffer, sourceName } = e.data;
    const data = new Uint8Array(buffer);
    const len = data.length;
    let results = [];
    
    const SIGS = {
      png: [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A],
      jpg: [0xFF, 0xD8, 0xFF],
      gif: [0x47, 0x49, 0x46, 0x38],
      riff: [0x52, 0x49, 0x46, 0x46], // RIFF (Wav, Webp)
      ogg:  [0x4F, 0x67, 0x67, 0x53], // OggS
      id3:  [0x49, 0x44, 0x33],       // MP3 ID3
      dds:  [0x44, 0x44, 0x53, 0x20], // DDS
      ktx:  [0xAB, 0x4B, 0x54, 0x58], // KTX
      unity:[0x55, 0x6E, 0x69, 0x74, 0x79, 0x46, 0x53] // UnityFS
    };

    // Helper: Exact Match
    function match(off, sig) {
      if (off + sig.length > len) return false;
      for(let k=0; k<sig.length; k++) if(data[off+k] !== sig[k]) return false;
      return true;
    }

    // Helper: Find next header (to determine cut-off for formats without explicit size)
    function findNextHeader(start, maxScan) {
      const limit = Math.min(len, start + maxScan);
      // Skip a bit to avoid self-match
      for(let i = start + 4; i < limit; i++) {
        const b = data[i];
        // Fast check first byte of knownsigs
        if(b === 0x89 || b === 0xFF || b === 0x47 || b === 0x52 || b === 0x4F || b === 0x49 || b === 0x44 || b === 0xAB || b === 0x55) {
          // Check full signatures
          if (match(i, SIGS.png) || match(i, SIGS.jpg) || match(i, SIGS.gif) || 
              match(i, SIGS.riff) || match(i, SIGS.ogg) || match(i, SIGS.id3) ||
              match(i, SIGS.dds)  || match(i, SIGS.ktx) || match(i, SIGS.unity)) {
            return i;
          }
        }
      }
      return -1;
    }

    let i = 0;
    while(i < len) {
      let found = null;
      let nextI = i + 1;
      const b = data[i];

      // --- IMAGES ---
      if (b === 0x89 && match(i, SIGS.png)) {
         // Find IEND
         let end = -1;
         const iendSig = [0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82];
         for(let k=i+8; k<len-8; k++) {
             if(data[k] === 0x49 && match(k, iendSig)) { end = k; break; }
         }
         if(end !== -1) {
           const size = (end+8)-i;
           found = {cat:'image', ext:'png', mime:'image/png', start:i, size:size};
           nextI = i+size;
         }
      }
      else if (b === 0xFF && match(i, SIGS.jpg)) {
         // Find FF D9
         let end = -1; 
         // Limit scan to 10MB to prevent hangs
         const limit = Math.min(len, i + 10_000_000); 
         for(let k=i+2; k<limit; k++) {
            if(data[k] === 0xFF && data[k+1] === 0xD9) { end = k; break; }
         }
         if(end !== -1) {
            found = {cat:'image', ext:'jpg', mime:'image/jpeg', start:i, size:(end+2)-i};
            nextI = i+found.size;
         }
      }
      else if (b === 0x47 && match(i, SIGS.gif)) {
         // GIF terminator 00 3B
         let end = -1;
         for(let k=i+6; k<Math.min(len, i+5_000_000); k++) {
            if(data[k]===0x00 && data[k+1]===0x3B) { end=k; break; }
         }
         if(end !== -1) {
            found = {cat:'image', ext:'gif', mime:'image/gif', start:i, size:(end+2)-i};
            nextI = i+found.size;
         }
      }
      
      // --- AUDIO ---
      else if (b === 0x4F && match(i, SIGS.ogg)) {
         // OGG pages. Hard to find end without parsing.
         // Heuristic: Read until no "OggS" header found for 4KB? 
         // Or scan for next file header.
         const nextHead = findNextHeader(i, 5_000_000); // 5MB max for audio chunk if no other file found
         const size = (nextHead !== -1) ? nextHead - i : Math.min(len-i, 2_000_000);
         found = {cat:'audio', ext:'ogg', mime:'audio/ogg', start:i, size:size};
         nextI = i+size;
      }
      else if (b === 0x49 && match(i, SIGS.id3)) { // MP3 ID3
         const nextHead = findNextHeader(i, 5_000_000);
         const size = (nextHead !== -1) ? nextHead - i : Math.min(len-i, 3_000_000);
         found = {cat:'audio', ext:'mp3', mime:'audio/mpeg', start:i, size:size};
         nextI = i+size;
      }

      // --- RIFF (WAV or WEBP) ---
      else if (b === 0x52 && match(i, SIGS.riff)) {
         const fileSize = data[i+4] | (data[i+5]<<8) | (data[i+6]<<16) | (data[i+7]<<24);
         const type = String.fromCharCode(data[i+8], data[i+9], data[i+10], data[i+11]);
         if (type === 'WEBP') {
             found = {cat:'image', ext:'webp', mime:'image/webp', start:i, size:fileSize+8};
         } else if (type === 'WAVE') {
             found = {cat:'audio', ext:'wav', mime:'audio/wav', start:i, size:fileSize+8};
         }
         if(found && (found.size + i <= len)) nextI = i + found.size;
      }

      // --- DATA / TEXTURES ---
      else if (b === 0x55 && match(i, SIGS.unity)) {
         // UnityFS
         // Heuristic scan for end is unreliable, we usually need big endian size parse
         // Simplified: Scan for next header
         const nextHead = findNextHeader(i, 20_000_000);
         const size = (nextHead !== -1) ? nextHead - i : 1000;
         found = {cat:'data', ext:'unity3d', mime:'application/octet-stream', start:i, size:size};
         nextI = i+size;
      }
      else if (b === 0x44 && match(i, SIGS.dds)) {
         const nextHead = findNextHeader(i, 10_000_000);
         const size = (nextHead !== -1) ? nextHead - i : Math.min(len-i, 1_000_000);
         found = {cat:'data', ext:'dds', mime:'application/octet-stream', start:i, size:size};
         nextI = i+size;
      }

      if (found) {
        // Validation: Ignore tiny files (noise)
        if (found.size > 64) {
            const buf = data.slice(found.start, found.start + found.size);
            results.push({ buf: buf, ...found, source: sourceName });
        }
        i = nextI;
        while(i % 4 !== 0 && i < len) i++; // 4-byte align
      } else {
        i++;
      }
    }
    
    // Send back results
    const buffers = results.map(r => r.buf.buffer);
    self.postMessage({ results }, buffers);
    self.postMessage({ done: true });
  }
</script>

<script>
  // --- UI Elements ---
  const grid = document.getElementById('grid');
  const status = document.getElementById('status');
  const progressContainer = document.getElementById('progressContainer');
  const progressBar = document.getElementById('progressBar');
  const dlAllBtn = document.getElementById('dlAllBtn');
  const fileInput = document.getElementById('fileInput');

  // --- State ---
  let exportZip = new JSZip(); // Global zip for "Download All"
  let totalFiles = 0;
  let activeFilter = 'all';

  // --- Worker Setup ---
  const workerBlob = new Blob([document.getElementById('worker-code').textContent], {type: "text/javascript"});
  const workerUrl = URL.createObjectURL(workerBlob);

  fileInput.addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    // Reset
    grid.innerHTML = '';
    exportZip = new JSZip(); // Reset zip
    totalFiles = 0;
    updateDownloadBtn();
    status.textContent = 'Processing...';
    progressContainer.style.display = 'block';
    progressBar.style.width = '10%';

    // ZIP Handling
    if (file.name.match(/\.(zip|apk|jar|obb|ipa)$/i)) {
      status.textContent = 'Unpacking Archive...';
      try {
        const zip = await JSZip.loadAsync(file);
        const files = Object.keys(zip.files).filter(n => !zip.files[n].dir);
        let processed = 0;
        
        for (const name of files) {
          const data = await zip.files[name].async("uint8array");
          await scanBuffer(data.buffer, name);
          processed++;
          progressBar.style.width = Math.round((processed / files.length) * 100) + '%';
        }
      } catch(e) {
        console.error(e);
        status.textContent = 'Archive error. Scanning as binary...';
        const buf = await file.arrayBuffer();
        await scanBuffer(buf, file.name);
      }
    } else {
      status.textContent = 'Scanning Binary...';
      const buf = await file.arrayBuffer();
      await scanBuffer(buf, file.name);
      progressBar.style.width = '100%';
    }
    
    status.textContent = `Done. Found ${totalFiles} assets.`;
    setTimeout(() => progressContainer.style.display = 'none', 1000);
  });

  function scanBuffer(buffer, filename) {
    return new Promise(resolve => {
      const worker = new Worker(workerUrl);
      worker.onmessage = (e) => {
        if(e.data.results) {
          addResults(e.data.results);
        } else if (e.data.done) {
          worker.terminate();
          resolve();
        }
      };
      worker.postMessage({ buffer, sourceName: filename }, [buffer]);
    });
  }

  function addResults(items) {
    const frag = document.createDocumentFragment();
    
    items.forEach(item => {
      totalFiles++;
      
      // Add to Export ZIP
      // Naming collision handling:
      const uniqueName = `${totalFiles}_${item.ext}`;
      exportZip.file(`${item.cat}/${uniqueName}`, item.buf);

      // UI Creation
      const blob = new Blob([item.buf], {type: item.mime});
      const url = URL.createObjectURL(blob);
      const sizeStr = (item.size / 1024).toFixed(1) + ' KB';

      const div = document.createElement('div');
      div.className = 'card';
      div.dataset.cat = item.cat; // For filtering
      if (activeFilter !== 'all' && activeFilter !== item.cat) div.style.display = 'none';

      let preview = '';
      if (item.cat === 'image' && ['png','jpg','webp','gif'].includes(item.ext)) {
        preview = `<img src="${url}" loading="lazy" />`;
      } else if (item.cat === 'audio') {
        preview = `<audio controls src="${url}"></audio>`;
      } else {
        preview = `<div class="type-icon">${item.ext.toUpperCase()}</div>`;
      }

      div.innerHTML = `
        <div class="card-preview">${preview}</div>
        <div class="card-tags">
          <span class="tag tag-${item.cat.substring(0,3)}">${item.cat}</span>
          <span class="tag tag-dat">${item.ext}</span>
        </div>
        <div class="card-meta" title="${item.source}">Src: ${item.source}</div>
        <div class="card-meta">${sizeStr}</div>
        <a href="${url}" download="extract_${totalFiles}.${item.ext}" class="card-btn">Download</a>
      `;
      frag.appendChild(div);
    });

    grid.appendChild(frag);
    updateDownloadBtn();
  }

  // --- Filtering ---
  window.filter = function(cat) {
    activeFilter = cat;
    // Update buttons
    document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
    document.querySelector(`.filter-btn[onclick="filter('${cat}')"]`).classList.add('active');
    
    // Hide/Show cards
    const cards = document.querySelectorAll('.card');
    cards.forEach(c => {
      if (cat === 'all' || c.dataset.cat === cat) c.style.display = 'flex';
      else c.style.display = 'none';
    });
  };

  // --- Download All ---
  window.downloadAll = function() {
    if (totalFiles === 0) return;
    const btn = document.getElementById('dlAllBtn');
    const oldText = btn.textContent;
    btn.textContent = 'Zipping...';
    btn.disabled = true;

    exportZip.generateAsync({type:"blob"}).then(function(content) {
      const link = document.createElement('a');
      link.href = URL.createObjectURL(content);
      link.download = "GameRipper_Extract.zip";
      link.click();
      btn.textContent = oldText;
      btn.disabled = false;
    });
  };

  window.clearAll = function() {
    grid.innerHTML = '<div class="empty-state">Cleared. Ready for next file.</div>';
    exportZip = new JSZip();
    totalFiles = 0;
    updateDownloadBtn();
    status.textContent = 'Ready';
  };

  function updateDownloadBtn() {
    dlAllBtn.textContent = `Download All (${totalFiles})`;
    dlAllBtn.disabled = totalFiles === 0;
  }
</script>

</body>
</html>