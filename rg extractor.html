<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ultimate Unity & Image Extractor</title>
  <!-- Load JSZip for unpacking archives -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  
  <style>
    :root { --primary: #6366f1; --bg: #f8fafc; --text: #334155; }
    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: var(--bg); color: var(--text);
      margin: 0; padding: 20px;
      height: 100vh; display: flex; flex-direction: column;
      box-sizing: border-box;
    }

    header { text-align: center; margin-bottom: 20px; flex-shrink: 0; }
    h1 { margin: 0; color: #1e293b; font-size: 1.8rem; }
    p { margin: 5px 0; color: #64748b; font-size: 0.9rem; }

    .controls {
      background: white; padding: 20px; border-radius: 12px;
      box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
      display: flex; gap: 15px; align-items: center;
      flex-shrink: 0; margin-bottom: 20px;
    }

    .upload-btn {
      position: relative; overflow: hidden;
      background: var(--primary); color: white;
      padding: 10px 20px; border-radius: 8px;
      font-weight: 600; cursor: pointer;
      display: inline-flex; align-items: center;
      transition: background 0.2s; white-space: nowrap;
    }
    .upload-btn:hover { background: #4f46e5; }
    .upload-btn input { position: absolute; left: 0; top: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; }

    .status-bar { flex-grow: 1; display: flex; flex-direction: column; justify-content: center; }
    .status-text { font-size: 0.9rem; font-weight: 600; margin-bottom: 5px; }
    
    .progress-track { width: 100%; height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden; }
    .progress-fill { height: 100%; width: 0%; background: #22c55e; transition: width 0.2s; }

    /* Results Grid */
    #output {
      flex-grow: 1; overflow-y: auto;
      display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      grid-auto-rows: min-content; gap: 15px;
      padding-right: 5px;
    }

    .card {
      background: white; border: 1px solid #e2e8f0; border-radius: 8px;
      padding: 8px; display: flex; flex-direction: column;
      height: 180px; position: relative;
      transition: transform 0.2s;
    }
    .card:hover { transform: translateY(-3px); box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1); }

    .preview {
      flex: 1; background: #f1f5f9; border-radius: 6px;
      margin-bottom: 8px; overflow: hidden;
      display: flex; align-items: center; justify-content: center;
    }
    .preview img { width: 100%; height: 100%; object-fit: contain; }
    
    /* Format Badges */
    .fmt-badge {
      font-size: 0.7rem; font-weight: 800; padding: 2px 6px; border-radius: 4px;
      text-transform: uppercase; margin-bottom: 4px; display: inline-block;
    }
    .fmt-png { background: #dbeafe; color: #1e40af; }
    .fmt-jpg { background: #ffedd5; color: #9a3412; }
    .fmt-dds { background: #fae8ff; color: #86198f; } /* Purple for generic/texture */
    .fmt-ktx { background: #fae8ff; color: #86198f; }
    .fmt-unity { background: #1f2937; color: #f8fafc; }

    .meta { font-size: 0.75rem; color: #94a3b8; margin-bottom: 5px; text-overflow: ellipsis; overflow: hidden; white-space: nowrap; }

    .dl-btn {
      background: #e2e8f0; color: #475569; text-decoration: none;
      padding: 5px; border-radius: 4px; text-align: center;
      font-size: 0.8rem; font-weight: 600;
    }
    .dl-btn:hover { background: #cbd5e1; }

    .file-icon {
      font-weight: 900; color: #cbd5e1; font-size: 1.5rem; text-transform: uppercase;
    }
  </style>
</head>
<body>

<header>
  <h1>Unity Asset & Image Extractor</h1>
  <p>Supports: ZIP, APK, PNG, JPG, WEBP, DDS, KTX, BMP, GIF, UnityFS</p>
</header>

<div class="controls">
  <div class="upload-btn">
    <span>ðŸ“‚ Upload File / Zip</span>
    <input type="file" id="fileInput" />
  </div>
  <div class="status-bar">
    <div class="status-text" id="status">Ready</div>
    <div class="progress-track"><div class="progress-fill" id="progressBar"></div></div>
  </div>
</div>

<div id="output">
  <div style="grid-column:1/-1; text-align:center; color:#94a3b8; margin-top:50px;">
    Select a file to begin scanning. <br>Archives (.zip, .apk) will be unpacked automatically.
  </div>
</div>

<!-- WORKER: Handles pure byte scanning logic -->
<script id="worker-code" type="javascript/worker">
  self.onmessage = function(e) {
    const { buffer, sourceName } = e.data;
    const data = new Uint8Array(buffer);
    const len = data.length;
    let results = [];
    
    // Helper: Simple match
    function match(arr, off, pat) {
      if (off + pat.length > arr.length) return false;
      for (let i=0; i<pat.length; i++) if (arr[off+i] !== pat[i]) return false;
      return true;
    }

    // Helper: Search forward
    function find(arr, off, pat, limit) {
      const max = limit ? Math.min(arr.length, off+limit) : arr.length;
      for (let i=off; i<max - pat.length; i++) {
        if (arr[i] === pat[0]) { // fast check
          if (match(arr, i, pat)) return i;
        }
      }
      return -1;
    }

    let i = 0;
    while(i < len) {
      let found = null;
      let nextI = i + 1;
      const b = data[i];

      // 1. PNG
      if (b === 0x89 && match(data, i, [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A])) {
         const end = find(data, i+8, [0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82]); // IEND
         if (end !== -1) {
           const size = (end + 8) - i;
           found = { type: 'png', ext: 'png', mime: 'image/png', start: i, size: size };
           nextI = i + size;
         }
      }
      // 2. JPG
      else if (b === 0xFF && data[i+1] === 0xD8 && data[i+2] === 0xFF) {
         // Heuristic: Scan for EOI (FF D9). 
         let ptr = i + 2;
         let end = -1;
         // look ahead max 20MB for jpg end to prevent freezing on massive false positives
         const scanLimit = 20 * 1024 * 1024; 
         end = find(data, ptr, [0xFF, 0xD9], scanLimit);
         
         if (end !== -1) {
           const size = (end + 2) - i;
           if (size > 150) { // filter tiny junk
             found = { type: 'jpg', ext: 'jpg', mime: 'image/jpeg', start: i, size: size };
             nextI = i + size;
           }
         }
      }
      // 3. UnityFS (AssetBundle)
      else if (b === 0x55 && match(data, i, [0x55, 0x6E, 0x69, 0x74, 0x79, 0x46, 0x53])) { // UnityFS
         // Try to parse size from header
         try {
            let ptr = i + 8; // skip UnityFS\0
            ptr += 4; // version
            // skip strings
            while(ptr < len && data[ptr] !== 0) ptr++; ptr++;
            while(ptr < len && data[ptr] !== 0) ptr++; ptr++;
            // Size is BigEndian Int64
            const h = (data[ptr]<<24)|(data[ptr+1]<<16)|(data[ptr+2]<<8)|data[ptr+3];
            const l = (data[ptr+4]<<24)|(data[ptr+5]<<16)|(data[ptr+6]<<8)|data[ptr+7];
            const size = (h * 4294967296) + (l>>>0);
            if (size > 0 && i+size <= len) {
               found = { type: 'unity', ext: 'unity3d', mime: 'application/octet-stream', start: i, size: size };
               nextI = i + size;
            }
         } catch(e){}
      }
      // 4. DDS (DirectDraw Surface) - 0x44 0x44 0x53 0x20
      else if (b === 0x44 && match(data, i, [0x44, 0x44, 0x53, 0x20])) {
         // DDS header is 124 bytes. But we need total file size. 
         // DDS doesn't strictly store file size in header, usually Texture dimensions + Mipmaps.
         // Heuristic: Scan until we hit another known header or reasonable limit? 
         // Actually, raw DDS extraction is tricky without size. 
         // Strategy: Assume contiguous block until next potential header or EOF.
         // Warning: This is a loose extraction.
         let potentialEnd = len;
         // Look for next PNG/JPG/Unity/DDS header to cut off
         // This is slow, so we just grab a chunk or rely on the fact that inside Unity assets,
         // textures are usually distinct blocks.
         // For now, let's grab the Header + reasonable data or up to 5MB
         const estSize = Math.min(len - i, 5 * 1024 * 1024);
         found = { type: 'dds', ext: 'dds', mime: 'application/octet-stream', start: i, size: estSize };
         nextI = i + 128; // Just skip header to avoid loops, DDS extraction is partial support
      }
      // 5. KTX (Khronos Texture) - 0xAB 0x4B 0x54 0x58 0x20 0x31 0x31 0xBB
      else if (b === 0xAB && match(data, i, [0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB])) {
          found = { type: 'ktx', ext: 'ktx', mime: 'application/octet-stream', start: i, size: Math.min(len-i, 1024*1024*10) };
          nextI = i + 64; 
      }
      // 6. GIF (GIF8)
      else if (b === 0x47 && match(data, i, [0x47, 0x49, 0x46, 0x38])) {
         const end = find(data, i+6, [0x00, 0x3B]); // Terminator
         if(end !== -1) {
             found = { type: 'gif', ext: 'gif', mime: 'image/gif', start: i, size: (end+2)-i };
             nextI = i + found.size;
         }
      }

      if (found) {
        // Copy data for transfer
        const buf = data.slice(found.start, found.start + found.size);
        results.push({ buf: buf, ...found, source: sourceName });
        i = nextI;
        // Padding align
        while(i % 4 !== 0 && i < len) i++;
      } else {
        i++;
      }
    }

    if (results.length > 0) {
      // Transfer buffers
      const buffers = results.map(r => r.buf.buffer);
      self.postMessage({ results }, buffers);
    }
    self.postMessage({ done: true });
  }
</script>

<script>
  const fileInput = document.getElementById('fileInput');
  const output = document.getElementById('output');
  const status = document.getElementById('status');
  const progressBar = document.getElementById('progressBar');

  // Create Worker
  const blob = new Blob([document.getElementById('worker-code').textContent], {type: "text/javascript"});
  const workerUrl = URL.createObjectURL(blob);
  let globalCount = 0;

  fileInput.addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    // Reset UI
    output.innerHTML = '';
    globalCount = 0;
    status.textContent = 'Analyzing file structure...';
    progressBar.style.width = '10%';

    // Detect ZIP/APK by Magic Numbers or Extension
    if (file.name.match(/\.(zip|apk|jar|obb)$/i)) {
      status.textContent = 'Unzipping archive... (This may take a moment)';
      try {
        const zip = await JSZip.loadAsync(file);
        const fileNames = Object.keys(zip.files);
        status.textContent = `Archive loaded. Scanning ${fileNames.length} files...`;
        
        let processed = 0;
        // Iterate files in zip
        for (const filename of fileNames) {
          if (zip.files[filename].dir) continue;
          
          // Get data
          const fileData = await zip.files[filename].async("uint8array");
          
          // Send to scanner
          await runScanner(fileData.buffer, filename);
          
          processed++;
          progressBar.style.width = ((processed / fileNames.length) * 100) + '%';
        }
        status.textContent = `Completed. Scanned ${fileNames.length} files. Found ${globalCount} assets.`;

      } catch (err) {
        console.error(err);
        status.textContent = 'Error reading ZIP. Scanning as raw binary...';
        const buf = await file.arrayBuffer();
        await runScanner(buf, file.name);
      }
    } else {
      // Normal binary scan
      status.textContent = 'Scanning raw binary...';
      const buf = await file.arrayBuffer();
      await runScanner(buf, file.name);
      status.textContent = `Completed. Found ${globalCount} assets.`;
      progressBar.style.width = '100%';
    }
  });

  // Function to run worker on a specific buffer
  function runScanner(buffer, name) {
    return new Promise((resolve) => {
      const worker = new Worker(workerUrl);
      
      worker.onmessage = (e) => {
        if (e.data.done) {
          worker.terminate();
          resolve();
        } else if (e.data.results) {
          renderResults(e.data.results);
        }
      };

      // Send buffer to worker
      worker.postMessage({ buffer, sourceName: name }, [buffer]);
    });
  }

  function renderResults(items) {
    const fragment = document.createDocumentFragment();
    items.forEach(item => {
      globalCount++;
      const card = document.createElement('div');
      card.className = 'card';

      const blob = new Blob([item.buf], {type: item.mime});
      const url = URL.createObjectURL(blob);
      const sizeKB = (item.size / 1024).toFixed(1);

      // Handle Preview
      let previewHTML = '';
      if (['png','jpg','gif','webp'].includes(item.ext)) {
        previewHTML = `<img src="${url}" loading="lazy" />`;
      } else {
        // For Unity, DDS, KTX -> Show Text Icon
        previewHTML = `<div class="file-icon">${item.ext.toUpperCase()}</div>`;
      }

      card.innerHTML = `
        <div class="preview">${previewHTML}</div>
        <div class="meta" title="Source: ${item.source}">Src: ${item.source}</div>
        <div class="meta">
          <span class="fmt-badge fmt-${item.type}">${item.ext}</span>
          ${sizeKB} KB
        </div>
        <a href="${url}" download="${item.source}_extracted_${globalCount}.${item.ext}" class="dl-btn">Download</a>
      `;
      fragment.appendChild(card);
    });
    output.appendChild(fragment);
  }
</script>
</body>
</html>