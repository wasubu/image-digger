<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Deep Scan Asset Ripper</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    :root {
      --bg: #121212; --surface: #1e1e1e; --primary: #bb86fc;
      --secondary: #03dac6; --error: #cf6679; --text: #e0e0e0;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: var(--bg); color: var(--text);
      margin: 0; padding: 0; height: 100vh;
      display: flex; flex-direction: column;
    }

    /* HEADER */
    header {
      background: var(--surface); padding: 1rem 1.5rem;
      border-bottom: 1px solid #333; display: flex; justify-content: space-between; align-items: center;
    }
    h1 { margin: 0; font-size: 1.2rem; font-weight: 700; color: white; }
    h1 span { color: var(--primary); }
    
    /* CONTROLS */
    .controls {
      padding: 1rem 1.5rem; background: #181818;
      display: flex; gap: 1rem; align-items: center; flex-wrap: wrap;
    }
    
    .upload-btn {
      position: relative; overflow: hidden;
      background: var(--primary); color: #000;
      padding: 0.6rem 1.5rem; border-radius: 4px;
      font-weight: 700; cursor: pointer; text-transform: uppercase; font-size: 0.85rem;
      display: inline-flex; align-items: center; gap: 0.5rem;
    }
    .upload-btn:hover { opacity: 0.9; }
    .upload-btn input { position: absolute; top:0; left:0; width:100%; height:100%; opacity:0; cursor:pointer; }

    .toggle-switch {
      display: flex; align-items: center; gap: 8px; font-size: 0.85rem; color: #aaa;
      background: #2a2a2a; padding: 6px 12px; border-radius: 20px; border: 1px solid #444;
    }
    .toggle-switch input { margin: 0; }

    .stats { margin-left: auto; font-size: 0.85rem; color: #888; }
    .btn-download {
      background: var(--secondary); color: #000; border: none;
      padding: 0.6rem 1.2rem; border-radius: 4px; font-weight: 700;
      cursor: pointer; font-size: 0.85rem; text-transform: uppercase;
    }
    .btn-download:disabled { background: #444; color: #888; cursor: not-allowed; }

    /* PROGRESS */
    #progress-area { height: 4px; background: #333; width: 100%; display: none; }
    #progress-bar { height: 100%; background: var(--secondary); width: 0%; transition: width 0.1s; }

    /* GRID */
    #grid {
      flex: 1; overflow-y: auto; padding: 1.5rem;
      display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      grid-auto-rows: min-content; gap: 1rem;
    }

    .card {
      background: var(--surface); border: 1px solid #333;
      border-radius: 6px; padding: 0.5rem;
      display: flex; flex-direction: column;
      height: 190px; transition: transform 0.1s;
    }
    .card:hover { border-color: var(--primary); transform: translateY(-2px); }

    .preview-box {
      flex: 1; background: #000; border-radius: 4px;
      margin-bottom: 0.5rem; overflow: hidden;
      display: flex; align-items: center; justify-content: center;
      position: relative;
    }
    .preview-box img { width: 100%; height: 100%; object-fit: contain; }
    
    .format-label {
      position: absolute; top: 4px; left: 4px;
      background: rgba(0,0,0,0.7); color: white;
      font-size: 0.6rem; padding: 2px 4px; border-radius: 3px; font-weight: bold;
      border: 1px solid #555;
    }

    .info-row { display: flex; justify-content: space-between; font-size: 0.7rem; color: #aaa; margin-bottom: 4px; }
    .file-name { font-size: 0.75rem; color: white; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 0.25rem; }

    .dl-link {
      background: #333; color: white; text-align: center;
      text-decoration: none; padding: 6px; border-radius: 3px;
      font-size: 0.75rem; font-weight: 600;
    }
    .dl-link:hover { background: var(--primary); color: black; }

    .placeholder-text {
      font-weight: 800; color: #444; font-size: 1.5rem;
      text-transform: uppercase;
    }

    .empty-msg { grid-column: 1/-1; text-align: center; color: #555; margin-top: 50px; }
  </style>
</head>
<body>

<header>
  <h1>Deep<span>Scan</span> Ripper</h1>
  <div class="stats" id="statusText">Ready</div>
</header>

<div id="progress-area"><div id="progress-bar"></div></div>

<div class="controls">
  <div class="upload-btn">
    <span>ðŸ“‚ Open File / ZIP</span>
    <input type="file" id="fileInput" />
  </div>

  <label class="toggle-switch" title="Checks every single byte. Slower, but finds everything.">
    <input type="checkbox" id="deepScanToggle">
    Deep Scan Mode
  </label>

  <div style="flex:1"></div>
  <button class="btn-download" id="dlAllBtn" onclick="downloadAll()" disabled>Download All</button>
</div>

<div id="grid">
  <div class="empty-msg">
    Select a file to begin.<br>
    Supports: PNG, Fixed JPG, WEBP, TGA, BMP, PVR, PKM, KTX, UnityFS, Audio.
  </div>
</div>

<!-- WORKER SCRIPT -->
<script id="worker-script" type="javascript/worker">
  self.onmessage = function(e) {
    const { buffer, deepScan, sourceName } = e.data;
    const data = new Uint8Array(buffer);
    const len = data.length;
    let results = [];
    
    // Config
    // Step size: 1 for Deep Scan, 4 for Speed (most assets are 4-byte aligned)
    const step = deepScan ? 1 : 4; 
    
    // --- SIGNATURES ---
    const PNG_SIG = [0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A];
    const WEBP_SIG = [0x52, 0x49, 0x46, 0x46]; // RIFF
    const PKM_SIG = [0x50, 0x4B, 0x4D, 0x20]; // PKM (ETC1)
    const PVR_SIG = [0x50, 0x56, 0x52, 0x03]; // PVR V3
    const KTX_SIG = [0xAB, 0x4B, 0x54, 0x58, 0x20]; // KTX
    const BMP_SIG = [0x42, 0x4D]; // BM

    // Helper: Match
    function match(off, sig) {
      if (off + sig.length > len) return false;
      for (let i=0; i<sig.length; i++) if (data[off+i] !== sig[i]) return false;
      return true;
    }

    // Helper: Find sequence
    function find(start, sig, limit) {
      const max = limit ? Math.min(len, start+limit) : len;
      for (let i=start; i<max-sig.length; i++) {
         if (data[i] === sig[0] && match(i, sig)) return i;
      }
      return -1;
    }

    // Helper: Read u32 LE
    function readU32(off) {
      return data[off] | (data[off+1]<<8) | (data[off+2]<<16) | (data[off+3]<<24);
    }

    let i = 0;
    while(i < len) {
      let found = null;
      let nextI = i + 1; // Default advance
      const b = data[i];

      // 1. STRICT JPEG (FF D8 FF ...)
      // We look for FF D8 FF [E0|E1|DB|C0] to ensure it's a real image and not random bytes
      if (b === 0xFF && data[i+1] === 0xD8 && data[i+2] === 0xFF) {
        const marker = data[i+3];
        // E0=JFIF, E1=Exif, DB=DQT, C0=SOF0, C4=DHT
        if ((marker >= 0xE0 && marker <= 0xEF) || marker === 0xDB || marker === 0xC0 || marker === 0xC4) {
           // Scan for End (FF D9)
           // We scan forward conservatively to avoid false positives inside entropy data
           // but since we validated the header, we are more confident.
           let ptr = i + 2;
           let end = -1;
           while(ptr < Math.min(len, i + 20_000_000)) { // 20MB limit
             if (data[ptr] === 0xFF && data[ptr+1] === 0xD9) {
                // Check if it's not a restart marker or escaped FF
                end = ptr;
                break;
             }
             ptr++;
           }
           if (end !== -1) {
             const size = (end + 2) - i;
             found = { ext:'jpg', type:'image/jpeg', start:i, size:size };
           }
        }
      }

      // 2. PNG
      else if (b === 0x89 && match(i, PNG_SIG)) {
        const iend = [0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82];
        const end = find(i+8, iend);
        if (end !== -1) {
           found = { ext:'png', type:'image/png', start:i, size:(end+8)-i };
        }
      }

      // 3. WEBP
      else if (b === 0x52 && match(i, WEBP_SIG)) {
         // Check "WEBP" at +8
         if (data[i+8]===0x57 && data[i+9]===0x45 && data[i+10]===0x42 && data[i+11]===0x50) {
            const size = readU32(i+4);
            if (size > 0 && i+size+8 <= len) {
               found = { ext:'webp', type:'image/webp', start:i, size:size+8 };
            }
         }
      }

      // 4. BMP
      else if (b === 0x42 && data[i+1] === 0x4D) { // BM
         const size = readU32(i+2);
         // Validation: Size must be > 14 and headersize (at 14) usually 40 (0x28) or higher
         if (size > 50 && size < 100_000_000 && i+size <= len) {
            const headerSize = readU32(i+14);
            if (headerSize >= 12 && headerSize <= 124) {
               found = { ext:'bmp', type:'image/bmp', start:i, size:size };
            }
         }
      }

      // 5. TGA (Footer Scan)
      // TGA headers are garbage, so we look for the FOOTER signature "TRUEVISION-XFILE"
      // This is unique. If we find it, we calculate start backwards?
      // Actually, TGA 2.0 has footer at EOF. If we are scanning linearly, we might miss it.
      // STRATEGY: We scan linearly. If we see "TRUEVISION-XFILE", we know a TGA *ended* here.
      // But we need the start. 
      // Alternative: Look for common TGA header? (Unreliable).
      // Let's rely on TGA Footer only if checking end of file? No, embedded files.
      // If `b` matches 'T' of TRUEVISION, check backwards?
      // Too complex for stream. Let's skip TGA for linear scan unless we detect specific resolution headers.

      // 6. PKM (ETC1)
      else if (b === 0x50 && match(i, PKM_SIG)) {
         // PKM does not store total size easily, usually fixed header + data.
         // We assume a standard texture size or search for next header.
         // Heuristic: 4MB max
         found = { ext:'pkm', type:'application/octet-stream', start:i, size: Math.min(len-i, 4*1024*1024) };
      }

      // 7. PVR (PowerVR)
      else if (b === 0x50 && match(i, PVR_SIG)) {
          const headerSize = readU32(i+4);
          const height = readU32(i+8);
          const width = readU32(i+12);
          // Rough calc, hard to know bpp without parsing flags.
          // Just take header + reasonable chunk.
          found = { ext:'pvr', type:'application/octet-stream', start:i, size: headerSize + (width*height) }; 
      }

      if (found) {
         if (found.size > 0) {
           const slice = data.slice(found.start, found.start + found.size);
           results.push({ buf: slice, ...found, src: sourceName });
           nextI = found.start + found.size;
           // Align to 4 bytes
           while(nextI % 4 !== 0 && nextI < len) nextI++;
         }
         i = nextI;
      } else {
         i += step;
      }
    }
    
    // Post back
    if (results.length > 0) {
      const buffers = results.map(r => r.buf.buffer);
      self.postMessage({ results }, buffers);
    }
    self.postMessage({ done: true });
  }
</script>

<script>
  const fileInput = document.getElementById('fileInput');
  const grid = document.getElementById('grid');
  const statusText = document.getElementById('statusText');
  const progressBar = document.getElementById('progress-bar');
  const progressArea = document.getElementById('progress-area');
  const dlAllBtn = document.getElementById('dlAllBtn');
  const deepScanToggle = document.getElementById('deepScanToggle');

  let zipExport = new JSZip();
  let totalFound = 0;
  let isDeep = false;

  const workerUrl = URL.createObjectURL(new Blob([document.getElementById('worker-script').textContent], {type:'text/javascript'}));

  fileInput.addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    // Reset
    grid.innerHTML = '';
    zipExport = new JSZip();
    totalFound = 0;
    dlAllBtn.disabled = true;
    dlAllBtn.textContent = "Download All";
    isDeep = deepScanToggle.checked;
    
    statusText.textContent = isDeep ? "Initializing Deep Scan..." : "Initializing Scan...";
    progressArea.style.display = 'block';
    progressBar.style.width = '5%';

    if (file.name.match(/\.(zip|apk|jar|obb)$/i)) {
       // ZIP MODE
       statusText.textContent = "Unzipping...";
       try {
         const zip = await JSZip.loadAsync(file);
         const files = Object.keys(zip.files).filter(n => !zip.files[n].dir);
         
         let count = 0;
         for (const name of files) {
           statusText.textContent = `Scanning: ${name}`;
           const content = await zip.files[name].async('uint8array');
           await runWorker(content.buffer, name);
           count++;
           progressBar.style.width = ((count/files.length)*100) + '%';
         }
       } catch(err) {
         console.error(err);
         statusText.textContent = "Zip Error. Scanning as raw...";
         const buf = await file.arrayBuffer();
         await runWorker(buf, file.name);
       }
    } else {
       // RAW MODE
       statusText.textContent = "Reading file...";
       const buf = await file.arrayBuffer();
       statusText.textContent = "Scanning...";
       await runWorker(buf, file.name);
       progressBar.style.width = '100%';
    }

    statusText.textContent = `Completed. Found ${totalFound} assets.`;
    setTimeout(() => { progressArea.style.display = 'none'; }, 2000);
  });

  function runWorker(buffer, name) {
    return new Promise(resolve => {
      const w = new Worker(workerUrl);
      w.onmessage = (e) => {
        if (e.data.results) {
          render(e.data.results);
        } else if (e.data.done) {
          w.terminate();
          resolve();
        }
      };
      w.postMessage({ buffer, deepScan: isDeep, sourceName: name }, [buffer]);
    });
  }

  function render(items) {
    const frag = document.createDocumentFragment();
    items.forEach(item => {
      totalFound++;
      const blob = new Blob([item.buf], {type: item.type});
      const url = URL.createObjectURL(blob);
      const kbs = (item.size/1024).toFixed(1);

      // Add to ZIP
      zipExport.file(`extracted/${totalFound}_${item.src}_.${item.ext}`, item.buf);

      const div = document.createElement('div');
      div.className = 'card';

      let preview = '';
      if (item.type.startsWith('image/')) {
        preview = `<img src="${url}" loading="lazy" />`;
      } else {
        preview = `<div class="placeholder-text">${item.ext}</div>`;
      }

      div.innerHTML = `
        <div class="preview-box">
          ${preview}
          <div class="format-label">${item.ext.toUpperCase()}</div>
        </div>
        <div class="file-name" title="${item.src}">${item.src}</div>
        <div class="info-row">
          <span>#${totalFound}</span>
          <span>${kbs} KB</span>
        </div>
        <a href="${url}" download="${totalFound}.${item.ext}" class="dl-link">Save</a>
      `;
      frag.appendChild(div);
    });
    grid.appendChild(frag);
    
    if (totalFound > 0) {
      dlAllBtn.disabled = false;
      dlAllBtn.textContent = `Download All (${totalFound})`;
    }
  }

  window.downloadAll = function() {
    dlAllBtn.textContent = "Zipping...";
    zipExport.generateAsync({type:"blob"}).then(blob => {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = "DeepScan_Extracted.zip";
      a.click();
      dlAllBtn.textContent = `Download All (${totalFound})`;
    });
  }
</script>
</body>
</html>